import csv
import sys
from basestructures import BaseStructures

#
# This class is meant to compare, manipulate and do other stuff with 
# the data I have on EUCDM, i.e.
# get the names of the Data Elements,
# get the D.E. numbers, etc etc.
#

class Tools():

    # Compares format in CWs matrix with format in file containing my relations (the old version found e.g. in file toplevel.relations...).
    # Input is filename of the CW matrix and filename of the relations file.
    # Expects format to be in 4th column in the CW Matrix, and
    # in 5th column in the relations file.
    def compareWithCWMatrix1(self, csvfilename, relfilename):
        bs = BaseStructures()
        dedict = bs.getDEDict(csvfilename)
        relations = bs.getRelations(relfilename)
        for row in relations:
            if row[1] in dedict:
                if not dedict[row[1]][1] == row[4]:
                    print(row[1], ', formats differ: ', row[4], ' != ', dedict[row[1]][1])

    # Compares the values for 'column presence' in CWs matrix and my relations file.
    # Purpose is to check if we agree.
    def compareWithCWMatrix2(self, csvfilename, relfilename):
        bs = BaseStructures()
        dedict = bs.getDEDict(csvfilename)
        relations = bs.getRelations(relfilename)
        #    for row in relations:



    def checkuniqueness(self, filename):
        with open(filename) as csvfile:
            crdr = csv.reader(csvfile, delimiter=';')
            h = {}
            for row in crdr:
                if len(row[59].strip()) > 0:
                    if row[0] in h:
                        h[row[0]] = h[row[0]] + 1
                    else:
                        h[row[0]] = 1
                        
            for key in h:
                if h[key] != 1:
                    print(key + ' ' + str(key))
                    
    # Returns a dict where key is a unique key (generated by me) and the info for the Data Element as value (in a list).
    # Reads CSV file called filename. This file must be sorted by DENumber.
    # Returns a dict with following structure:
    # Key   = ID (just an integer assigned by me)
    # Value = [DataElement-number, EUCDM 5.2-id, Data Element name, datatype, elementtype]
    def constructDict(self, filename):
        dedict = {}

        with open(filename) as csvfile:
            crdr = csv.reader(csvfile, delimiter=';')
            i = 100         # DataElement-ID is given an arbitrary starting point, but one which leaves room at the bottom.

            for row in crdr:
                if row[0].lstrip().startswith('#'):
                    continue
                else:
                    denum = self.getDENumberSplitup(row[0])

                    if (denum[0] < 0):
                        elementtype = 'Level'
                    elif len(row[3].strip()) == 0:
                        elementtype = 'Container'
                    else:
                        elementtype = 'Datafield'
                    dedict[i] = [row[0], row[1], row[2], row[3], elementtype]
                    i = i + 1
                    
        return dedict


    # Returns a dict with the following content.
    # Key = 4 first digits in DENo as an integer.
    # Value = a graph with all underlying nodes for this DENo.
    # Based on the belief that a DE with number 12 01 000 000 is parent of all DEs
    # with number 12 01 xyz æøå, where at least one of [x,y,z,æ,ø,å] is > 0. 
    # NB: Only DEs where the last 6 digits equal zero are keys.
    # Input is a CSV file.
    def constructDict2(self, filename, Nodeclass):
        dedict = {}

    # setData() in this mthod needs to use same keys as in Graphs,
    # which is the key from dict made in constructDict().
    # But to do that, I need to be able to look it up using DENumber...
    # How?
        with open(filename) as csvfile:
            crdr = csv.reader(csvfile, delimiter=';')

            for row in crdr:
                if row[0].lstrip().startswith('#'):
                    continue
                else:
                    denum = self.getDENumberSplitup(row[0])
                    
                    prefix1 = self.getPrefix1(row[0])
                    prefix2 = self.getPrefix2(row[0])
                    prefix3 = self.getPrefix3(row[0])

                    if denum[0] <= 0:
                        continue
                    elif denum[2] == 0 and denum[3] == 0:
                        node = Nodeclass(prefix1, row[0])
                        dedict[prefix1] = node
                    elif denum[2] > 0 and denum[3] == 0:
                       if prefix1 not in dedict:
                           print("Missing this in dict: ", row[0])  # This means that we are missing parent for current DE.
                       else:
                           node = Nodeclass(prefix2, row[0])
                           dedict[prefix1].addChild(node)
                    elif denum[2] > 0 and denum[3] > 0:
                       if prefix1 not in dedict:
                           print("Missing this in dict: ", row[0])
                       else:
                           node = Nodeclass(prefix3, row[0])

                            # Now look for parent:
                           for kid in dedict[prefix1].getChildren():
                               if kid.getKey() == prefix2:
                                   kid.addChild(node)
                    
        return dedict

    # Construct a dict with key = denum and value = the corresponding key from DETable.
    # Resulting list is used for inverse lookup, i.e. looking up the key using denumber.
    def constructList(self, dedict):
        delist = {}

        for k in dedict:
            delist[dedict[k][0]] = k

        return delist

    # Read CSV file called filename. column = type of document, i.e. H1, H2, H3 etc.
    def readit(self, filename, column):
        with open(filename) as csvfile:
            crdr = csv.reader(csvfile, delimiter=';')
            i = 0
            for row in crdr:
                if len(row) < 10:
                    continue
                if len(row[column].strip()) > 0:
                    print(';'.join(row[0:3]) + ';' + row[column] + ';' + ';'.join(row[62:69]))
                    i = i+1
            print(str(i) + ' rows.')


if __name__ == "__main__":
    arg1 = sys.argv[1]
    arg2 = sys.argv[2]
    tool = Tools()
    # tool.compareWithCWMatrix(csvfilename, relfilename)
    tool.readit(arg1, int(arg2))
